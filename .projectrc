# .projectrc - Project-specific configuration for the 'project' CLI tool

PROJECT_COMMIT_TYPES=(
  chore
  fix
  new
  refactor
)

# Define what happens when we ENTER the directory
PROJECT_ON_LOAD=(
  "echo 'ðŸ› ï¸  Project Mode: Ink Dev Enabled'"
  # "export NODE_ENV=development"
)

# Define what happens when we LEAVE the directory
PROJECT_ON_UNLOAD=(
  "pkill -f 'tsx --watch'"      # Kill the watchers
  # "unset NODE_ENV"              # Clean up environment
)

typeset -A PROJECT_CUSTOM_COMMANDS

PROJECT_CUSTOM_COMMANDS=(
    build "Build Project -- npm run build"
		watch "Hot Re-Build -- npm run dev"
    examples  "Browse Examples"
)

project_list_files() {
    ls -lah
}

project_build() {
    npm run build
}

project_examples() {
		local pane_count=$(tmux list-panes | wc -l)
		local current_pane_id=$(tmux display-message -p '#{pane_id}')
		local target_pane_id=""

		# 1. Create the split only if needed
		if (( pane_count == 1 )); then
			# Capture the new ID immediately upon creation
			target_pane_id=$(tmux split-window -h -l 75% -P -F "#{pane_id}")
			tmux select-pane -t "$current_pane_id"
		else
			# If a split already exists, find the ID of the 'other' pane
			target_pane_id=$(tmux list-panes -F "#{pane_id}" | grep -v "$current_pane_id" | head -n 1)
		fi

		# 2. Run fzf
		find examples -name "*.tsx" | fzf \
			--reverse \
			--height=100% \
			--prompt="Ink Gallery > " \
			--bind "enter:execute(tmux send-keys -t $target_pane_id 'C-c' 'C-l' 'DEV=true npx tsx {}' Enter; tmux select-pane -t $target_pane_id)" \
			--header "Press ESC to exit gallery and close the right pane"

		# 3. Cleanup: Kill the specific target pane
		if [[ -n "$target_pane_id" ]]; then
			tmux kill-pane -t "$target_pane_id" 2>/dev/null
		fi
}

# @TODO: Move to project plugin
# The "Discovery" function for your project
project_gallery() {
    # Create a unique temp file for the command to exec
    local tmp_file=$(mktemp /tmp/mink_exec_cmd.XXXXXX)

    # Export the path so Ink knows where to write
    export MINK_OUTPUT_PATH="$tmp_file"

    # Run the Ink script (pass through any arguments like --stdout)
    # Using 'command' ensures we don't accidentally call the function recursively
    npx tsx examples/use-focus-with-id/use-focus-with-id.tsx "$@"


    # If the file exists and is not empty, it means a command was selected
    if [[ -s "$tmp_file" ]]; then
        local cmd=$(cat "$tmp_file")

        # Clean up the temp file
        rm "$tmp_file"

        # Execute the command in the current shell environment
        # This allows the command to access aliases, env vars, and functions
        eval "$cmd"
    else
        # Clean up if the user exited without selecting
        rm -f "$tmp_file"
    fi
}

project_run_test() {
		DEV=true npx tsx examples/use-focus/use-focus.tsx
}

run_example() {
		DEV=true npx tsx --watch examples/$1/$1.tsx
}

# Debug
project_gallery_spawn() {
    npx tsx examples/use-focus-with-id/use-focus-with-id.tsx --spawn "$@"
}

project_gallery_pass_back() {
    # Create a unique temp file to act as the "mailbox"
    local tmp_file=$(mktemp /tmp/ink_cmd.XXXXXX)

    # Export the path so Ink knows where to write
    export MINK_OUTPUT_PATH="$tmp_file"

    # Run the Ink script (pass through any arguments like --stdout)
    # Using 'command' ensures we don't accidentally call the function recursively
    npx tsx examples/use-focus-with-id/use-focus-with-id.tsx --pass-back "$@"

    # If the file exists and is not empty, it means a command was selected
    if [[ -s "$tmp_file" ]]; then
        local cmd=$(cat "$tmp_file")

        # Clean up the temp file
        rm "$tmp_file"

        echo "echo \$cmd >> /tmp/cmd."
        # Execute the command in the current shell environment
        # This allows the command to access aliases, env vars, and functions
        eval "$cmd"
    else
        # Clean up if the user exited without selecting
        rm -f "$tmp_file"
    fi
}

# Works!
# project_task_o() {
#   echo '[{"key":"b", "label": "Build All", "command": "yarn run build"},{"key": "e", "label": "Run Examples", "command": "project_examples"}]' | project_gallery
# }

# Works!
project_task_o() {
  project_gallery <<EOF
[
  {
    "key": "b",
    "label": "Build All",
    "command": "yarn run build"
  },
  {
    "key": "e",
    "label": "Run Examples",
    "command": "project_examples"
  }
]
EOF
}

# project_build_task() {
# 	echo "[{\"key\":\"b\", \"label\": \"Build $PROJECT_NAME\", \"command\": \"npm run build\"},{\"key\":\"e\",\"label\":\"Run Examples\", \"commands\": \"project_examples\"}]" | project_gallery
# }

# Define your project-specific mappings
# Syntax: KEY_SEQUENCE=WIDGET_NAME
typeset -A PROJECT_KEYS

project_run_with_args() {
	project_gallery --key b --label "Build All" --command "yarn run build" --key e --label "Run Examples" --command "project_examples" --key p --label "Project Menu" --command "project"
}

PROJECT_KEYS=(
    "^[a" "echo Hellow World"
    "^[t" "echo 'It works'"
    "^[r" "project_run_with_args"
    "^[o" "project_task_o"
    "^[b" "project_build_task"
		"^[p" "project"
    "^[w" "npm run dev"
    "^[e" "project_examples"
)
